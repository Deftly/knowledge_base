# Maven Dependency Management
- Enterprise level projects typically depend on a variety of open source libraries. 
- For example, if you want to include [[Log4J]] for application logging you would go to the Log4J download page and download the JAR file and put it in your project lib folder or add it to the project's class path. 
- There are a few problems with this approach:
	1. The JAR file you download might depend on a few other libraries. You would have to hunt down all of those dependencies (and their dependencies) and add them to your project.
	2. When the time comes to update the JAR file, you would need to start the process all over again.
	3. You need to add JAR files to source control along with your source code so that your projects can be built on a computer other than your own. This increases project size, checkout, and built time.
	4. Sharing JAR files across teams within your organization becomes difficult.

To address these problems, Maven provides declarative dependency management. You declare your project's dependencies in an external pom.xml file and Maven will automatically download those dependencies.  

![[Maven Dependency Management.png]]

- When you run a Maven project for the first time Maven connects to the network and downloads artifacts and related metadata from remote repositories. The default remote repository is called *Maven Central* and it is located at https://repo.maven.apache.org/. 
- Maven places a copy of these downloaded artifacts in its local repository and on subsequent runs will check the local repository first before attempting to download them from a remote repository.
- The above architecture works in the majority of cases but it does pose a few problems in an enterprise environment.
	1. The sharing of company-related artifacts between teams is not possible. Because of security and IP concerns you wouldn't want to publish your enterprise's artifacts on Maven Central.
	2. Your organization might want teams to only use officially approved open source software.
	3. In times of heavy load on Maven Central, the download speeds of Maven artifacts are reduced which might have a negative impact on your builds.
  
![[Enterprise Maven Repository Architecture.png]]
- The internal repository manager acts as a proxy to remote repositories, caching artifacts resulting in faster artifact downloads and build performance improvements. 
- Additionally because you have control over the internal repository you can regulate the types of artifacts allowed in your organization. 
- You can also push your organization's artifacts onto the repository manager, thereby enabling collaboration.
<br>


### Open Source Repository managers
| Repository Manager      | URL                                                |
| ----------------------- | -------------------------------------------------- |
| Nexus Repository OSS    | https://www.sonatype.com/products/nexus-repository |
| Apache Archiva          | https://archiva.apache.org/                        |
| Artifactory Open Source | https://jfrog.com/community/open-source/                                                   |

<br>

## Using New Repositories
- In order to use a new repository you need to modify your settings.xml file.  
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
http://maven.apache.org/xsd/settings-1.0.0.xsd">

...

  <profiles>
    <profile>
      <id>your_company</id>
      <repositories>
        <repository>
          <id>spring_repo</id>
          <url>http://repo.spring.io/release/</url>
        </repository>
        <repository>
          <id>jboss_repo</id>
          <url>https://repository.jboss.org/</url>
        </repository>
	  </repositories>
	</profile>
  </profiles>

  <activeProfiles>
  <activeProfile>your_company</activeProfile>
  </activeProfiles>

</settings>
```

<br>

## Dependency Identification
- Maven dependencies are typically archives such as JAR, WAR, EAR, or ZIP. Each Maven dependency is uniquely identified using the following:
	- **groupId:** Identifier of the organization or group that is responsible for this project. Examples: *org.hibernate, log4j, org.springframework* and com.companyname.
	- **artifactId:** Identifier of the artifact being generated by the project. This must be unique among the projects using the same **groupId**. Examples: hibernate-tools, log4j, spring-core, and so on.
	- **version:** Indicates the version number of the project. Examples: 1.0.0, 2.3.1-SNAPSHOT, 5.4.2.Final.
	- **type:** Indicatest he packaging of the generated artifact. Examples: JAR, WAR, EAR.
<br>
- Artifacts that are still in development are labeled with a SNAPSHOT in their versions, this tells Maven to look for an updated version of the artifact from remote repositories on a daily frequency.
- Dependencies are declared in a pom.xml file using the dependencies tag as show below:
```xml
<dependencies>
	<dependency>
		<groupId>org.hibernate</groupId>
		<artifactId>hibernate-tools</artifactId>
		<version>5.4.2.Final</version>
	</dependency>
</dependencies>
``` 
<br>

## Transitive Dependencies
- Dependencies declared in your project's pom.xml file have their own dependencies, these are known as *transitive dependencies*. 
	- Take Hibernate Core for example, to function properly it requires Jboss Logging, dom4J, javaassist, and so forth. A key benefit of maven is that it automatically deals with transitive dependencies and includes them in your project.
- Maven uses a technique known as *dependency mediation* to resolve version conflicts. Simply stated Maven pulls the dependency that is closest to the project in the dependency tree  

![[Maven Dependency Tree.png]]
<br>
- In the image above there are two version of dependency B: 0.0.8 and 1.0.0. In this scenario, version 0.0.8 of dependency B is included in the project because it is a direct dependency and *closest* to the the tree. 
- All three versions of dependency F (0.1.3, 1.0.0, 2.2.0) are all at the same depth. In this case Maven will use *first-found dependency* which would be 0.1.3. If you want maven to use the latest 2.20 version of artifact F, you need to explicitly add that version dependency to your pom.xml file.
- There are times where you don't want to include certain transitive dependency JARs in the final archive, for this Maven provides an "excludes" tag.
```xml
<dependencies>
	<dependency>
		<groupId>junit</groupId>
		<artifactId>junit</artifactId>
		<version>${junit.version}</version>
		<scope>test</scope>
		<exclusions>
			<exclusion>
				<groupId>org.hamcrest</groupId>
				<artifactId>hamcrest</artifactId>
			</exclusion>
		</exclusions>
	</dependency>
</dependencies>
```

## Dependency Scope
